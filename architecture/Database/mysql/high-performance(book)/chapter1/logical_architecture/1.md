# **Multivariate Concurrency Control (MVCC) in InnoDB**

## **1. The basic principles of MVCC**
MVCC (Multiversion Concurrency Control) is a mechanism that allows:
- Increase the parallelism of operations
- Avoid locks when reading
- Ensure data consistency

**How it works in InnoDB**:
- Each row contains two hidden fields:
- `creation_version` — the version of the transaction that created the record
  - `deletion_version' — the version of the transaction that deleted the record
- The version is a monotonously increasing transaction number

## **2. MVCC implementation for different operations**

### **2.1 SELECT**
InnoDB checks for each row:
1. The creation version is less than the current version of the transaction
2. The deletion version is not defined or > the current version of the transaction

```sql
-- The transaction with version 10 sees:
-- The line was created in version 5 and has not been deleted
```

### **2.2 INSERT**
Writes the current version to `creation_version`:
```sql
INSERT INTO t VALUES (1); -- creation_version = 12 (current version)
```

### **2.3 DELETE**
Writes the current version to the `deletion_version`:
```sql
DELETE FROM t WHERE id = 1; -- deletion_version = 15
```

### **2.4 UPDATE**
Creates a new row with the current version and marks the old one as deleted:
```sql
UPDATE t SET val = 2 WHERE id = 1;
-- Old line: deletion_version = 18
-- New line: creation_version = 18
```

## **3. Support for isolation levels**

| Isolation level  | MVCC support | Features                                                       |
| ---------------- | ------------ | -------------------------------------------------------------- |
| READ UNCOMMITTED | ❌ No         | Reading uncommitted data                                       |
| READ COMMITTED   | ✅ Yes        | Sees only committed changes                                    |
| REPEATABLE READ  | ✅ Yes        | Snapshot of the data at the start of the transaction (default) |
| SERIALIZABLE     | ❌ No         | Uses locks instead of MVCC                                     |

## **4. Advantages of MVCC**
1. **Non-blocking read**: SELECT does not block INSERT/UPDATE/DELETE
2. **High concurrency**: Multiple transactions can run simultaneously
3. **Consistency**: Ensures repeatable reads without locks

## **5. InnoDB Features**
-**Cluster Index**: The primary key includes all columns
- **Adaptive hash indexes**: Automatically created in memory
- **Pre-read**: Optimizing disk access
- **Insert Buffer**: Acceleration of INSERT operations

**Example of viewing information about a table**:
```sql
SHOW TABLE STATUS LIKE 'users'\G
```
The output includes:
- Engine type (Engine: InnoDB)
- Row format (Row_format: Dynamic)
- Size of data and indexes

## **6. Important limitations**
1. **Primary Key size**: Secondary indexes contain PK, so larger keys increase the size of the indexes
2. **Memory consumption**: MVCC requires additional storage space for versions
3. **Cleaning of old versions**: Cleaning of "outdated" data is required periodically

InnoDB's MVCC provides an excellent balance between data consistency and performance, making it an ideal choice for most applications.

♦️ Is MVCC embedded in innoDB❓
- MVCC is built right into InnoDB — it's an integral part of it, like an engine in a car.
 
♦️ What do others use❓

**MVCC is not a universal standard**, and not all DBMSs use it. Here's how things work in other popular systems.:

---

### **1. Relational databases (SQL)**
#### **✅ Use MVCC**
| MVCC System    | Features                                                                                                                   |
| -------------- | -------------------------------------------------------------------------------------------------------------------------- |
| **PostgreSQL** | The most advanced implementation. Stores all versions of rows in tables, allows you to configure the "visibility" of data. |
| **Oracle**     | Implementation via **undo logs** (separate repository of old versions).                                                    |
| **SQL Server** | Enabled via `READ COMMITTED SNAPSHOT` (not at all isolation levels).                                                       |

#### **❌ Don't use MVCC**
| System                    | What is being replaced with                                                          |
| ------------------------- | ------------------------------------------------------------------------------------ |
| **MyISAM** (MySQL engine) | Table locks only. Reading blocks writing, writing blocks everything.                 |
| **SQLite**                | Locking the entire database when writing (simultaneous access is extremely limited). |

---

### **2. NoSQL systems**
Everything is more complicated here — many NoSQL databases sacrifice consistency for speed:
| System        | Concurrency mechanism                                                                |
| ------------- | ------------------------------------------------------------------------------------ |
| **MongoDB**   | Optional MVCC (in the WiredTiger engine). By default, document—level locks are used. |
| **Redis**     | Single-threaded (there is no parallelism, but there are atomic operations).          |
| **Cassandra** | "Last Write Wins" (the last write overwrites the previous ones, without versioning). |

---

### **3. Alternatives to MVCC**
Where MVCC is not present, use:
1. **Locking**
- Example: `SELECT ... FOR UPDATE` in MySQL (explicit row locking).
   - Problem: reduces parallelism, possible deadlocks.

2. **Optimistic locking**
- Checking the version/hash of data before writing (for example, through `WHERE version = 5`).
   - Used in Elasticsearch and some REST API implementations.

3. **Eventual Consistency**
- Data is consistent "over time" (as in DynamoDB, Cassandra).
   - It is not suitable for all tasks (for example, not for banking operations).

---

### **4. When to choose what?**
- **Do you need transactions and concurrency?** → **InnoDB (MVCC)** or PostgreSQL.
- ** Only reading?** → MyISAM (but be careful with locks).
- **Ultra-high recording speed?** → Cassandra (without MVCC, with risk of losses).
- **Caching?** → Redis (single-threaded, but instant access).

---

### **Code Example: Locks vs MVCC**
#### **Without MVCC (MyISAM)**
```sql
-- Session 1:
LOCK TABLES users WRITE; -- Lock the entire table!
INSERT INTO users VALUES (1, 'Ivan');
-- Session 2 freezes:
SELECT * FROM users; -- Waiting for unblocking...
```

#### **With MVCC (InnoDB)**
```sql
-- Session 1:
START TRANSACTION;
INSERT INTO users VALUES (1, 'Ivan'); -- Does not block reading!
-- Session 2 runs in parallel:
SELECT * FROM users; -- Sees old data (if the isolation level is REPEATABLE READ)
```

---

**Bottom line**:
MVCC is the "gold standard" for SQL databases, but it is not the only option. The choice depends on the tasks.:  
- **Data accuracy** → MVCC (PostgreSQL, InnoDB).  
- **Recording speed** → Sometimes it's better to donate MVCC (NoSQL).  
- **Simplicity** → SQLite/MyISAM (but with limitations).



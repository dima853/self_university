## **2.5.11 Workload Characterization** 🚀  

Workload characterization is a simple and effective way to identify problems related to system load. Instead of analyzing system performance, this method focuses on the **input data** that the system processes.  

Your system may be perfectly designed and configured, but if the load exceeds its capacity, problems are inevitable! 😱  

### **🔍 Key questions for load analysis:**  
1. **Who creates the load?**  
   - Process ID, user, client IP address?
2. **Why does the load occur?**
- What code is being executed? (call stack, execution path)
3. **What are the load characteristics?**
- IOPS, throughput, type of operations (read/write), variance (standard deviation).  
4. **How does the load change over time?**
- Are there daily/weekly patterns? 📈  

### **🎯 Real-life example: "Unexpected DDoS attack on a database"**  
Let's say your database is slowing down, and your clients should only be web servers. You check the IP addresses and... It turns out that the database is being loaded ** from all over the Internet**! This is a **DoS attack**! 😱  

### **💡 How can I improve my performance?**  
The best way to speed up the system is to **eliminate unnecessary work**! For example:
- **Bug in the code**: the thread is stuck in an infinite loop → **CPU load**.  
- **Incorrect setting**: Backup during peak time.  
- **Attack**: as in the example above.  

If the load cannot be removed, you can **limit its impact** by using:  
- **Throttling** (for example, to lower the backup priority).  
- **Resource quotas** (CPU, network, disk).  

### **📌 Additional applications:**  
- **Create realistic benchmarks** (based on real load data).  
- **Separation of concerns** (load vs architecture).  

---

## **2.5.12 Drill-Down Analysis** 🔍  

This method starts with a **general overview** of the problem, and then gradually **narrows the focus**, cutting off irrelevant parts and delving into key areas.  

### **📌 Three-step methodology:**  
1. **Monitoring** 📊  
   - Constant collection of high-level statistics.  
   - Example: **SNMP**, **Prometheus + Grafana**.  
2. **Identification** 🎯
- Narrow it down to specific resources (CPU, disk, memory).  
   - Tools: 'vmstat', `iostat', `mpstat'.  
3. **Analysis** 🔬
- In-depth analysis of the problem: **tracing, profiling, code reading**.  
   - Tools: `strace`, `perf', **BCC/bpftrace**, **Ftrace**.  

### **🌐 An example from Netflix:**  
1. **Atlas** (monitoring of the entire infrastructure).  
2. **perfdash** (analysis of a specific instance).  
3. **FlameCommander** (flamethrowers for CPU/off-CPU analysis).  

### **❓ The "Five Whys" Method**  
Example:  
1. **Why is the database slowing down?** → Due to disk operations.  
2. **Why are disk operations slow?** → Because there is a swap going on.
3. **Why swap?** → Because there is not enough RAM.  
4. **Why is there not enough RAM?** → The allocator is fragmented.  
5. **Why is the allocator fragmented?** → Bug in the jemalloc library.  

**Output:** Sometimes the problem is hidden ** deeper than it seems!**  

---

## **2.5.13 Latency Analysis** ⏳  

This method breaks down the **total operation time** into small components to find the **main source of delay**.  

### **📌 Example: MySQL Latency Analysis**  
1. Is there a problem with the requests? → **Yes**.  
2. Are requests slowing down on the CPU or waiting for I/O? → **Waiting for I/O**.
3. Which I/O exactly? → **Read from disk**.  
4. Is there a delay due to the queue or a slow disk? → **Slow disk**.  
5. Is the disk slowing down due to initialization or data transfer? → **Data transmission**.  

**Output:** It takes time **to read big data from disk** → you need to optimize indexes or caching.  

---

## **2.5.14 Method R** 🎯  

The R method is a delay analysis developed for Oracle, but applicable to other systems as well.  

**The essence:**  
- Tracing the execution of requests.  
- We break down the time into components.  
- We find ** the most expensive operations**.  

**Example:**  
```sql
-- Tracing can be used in Oracle:
ALTER SESSION SET tracefile_identifier = 'slow_query';
ALTER SESSION SET events '10046 trace name context forever, level 12';
-- Executing a slow query...
ALTER SESSION SET events '10046 trace name context off';
``
Then we analyze the trace file to understand where the time is being spent.  

**Output:** This method helps to **accurately locate bottlenecks** in complex systems.  

---

### **💬 Conclusion**  
Each of these methodologies helps **approach performance analysis**in a different way. The choice depends on **the type of problem** and **the available tools**.  

**The main thing:**  
***Do not guess**, but **measure**.  
✅**Break the problem** into pieces.  
***Use the right tools**.
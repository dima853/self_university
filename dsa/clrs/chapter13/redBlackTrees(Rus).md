## 13.1 Свойства Красно-Черных Деревьев

Красно-Черное Дерево — это самобалансирующееся Бинарное Дерево Поиска (БДП) с простым, но мощным дополнением: каждый узел имеет **дополнительный бит для цвета**, который может быть либо **КРАСНЫМ**, либо **ЧЕРНЫМ**.

Цвета — не цель; они — **инструмент**. Конкретный цвет любого отдельного узла не важен. Важно то, что, следуя набору из пяти правил, касающихся этих цветов, дерево может гарантировать эффективную производительность. Вы можете перекрашивать узлы по-разному — само дерево выбирает допустимую раскраску во время операций балансировки. Основной принцип:

> **Цвета — как краска на заборе — вы можете перекрасить его, пока забор остается структурно прочным.**

Пять правил, которые создают эту «прочную структуру»:

1.  **Каждый узел является либо красным, либо черным.**
2.  **Корень всегда черный.**
3.  **Все листья (NIL) являются черными.**
4.  **Если узел красный, то оба его потомка должны быть черными.** (Не может быть двух красных узлов подряд).
5.  **Для каждого узла все простые пути от него до листьев-потомков содержат одинаковое количество черных узлов.** (Одинаковая «Черная Высота»).

---

### 1. Базовая Структура Узла

Каждый узел в Красно-Черном Дереве содержит следующие атрибуты для поддержания своей структуры и цвета:

```
+-------------------+
|      Узел         |
|  +-------------+  |
|  |    color    |  |  // КРАСНЫЙ или ЧЕРНЫЙ
|  |     key     |  |  // Значение данных
|  | left | right|  |  // Указатели на потомков
|  |    p        |  |  // Указатель на родителя
|  +-------------+  |
+-------------------+
    /        \
   /          \
ЛЕВЫЙ       ПРАВЫЙ
ПОТОМОК     ПОТОМОК
```

---

### 2. Визуализация Пяти Свойств

Давайте рассмотрим допустимое Красно-Черное Дерево, чтобы увидеть эти правила в действии. Листья NIL показаны как черные квадраты (■).

```
        11(Ч)
        /    \
       /      \
     2(К)      14(Ч)
    /   \       /   \
  1(Ч)  7(Ч)   ■    15(К)
 /  \   /  \        /   \
■    ■ 5(К) ■      ■     ■
        / \
       ■   ■
```

**Теперь давайте проверим все пять свойств на этой диаграмме:**

*   **✅ Свойство 1: Каждый узел является либо красным, либо черным.**
    *   Визуально представлено `(Ч)` для Черного и `(К)` для Красного.

*   **✅ Свойство 2: Корень всегда черный.**
    *   Корневой узел `11` черный.

*   **✅ Свойство 3: Каждый лист (NIL) является черным.**
    *   Все указатели `NIL` представлены как черные квадраты (■).

*   **✅ Свойство 4: Красные узлы имеют черных потомков.**
    *   Проверим красные узлы:
        *   Узел `2(К)`: Его потомки `1(Ч)` и `7(Ч)`.
        *   Узел `5(К)`: Его потомки оба `NIL` (черные).
        *   Узел `15(К)`: Его потомки оба `NIL` (черные).

*   **✅ Свойство 5: Все пути от узла до листьев-потомков содержат одинаковое количество черных узлов.**
    *   **От корня (11):**
        *   Путь 11(Ч) → 2(К) → 1(Ч) → NIL: **2 Черных Узла** (11, 1)
        *   Путь 11(Ч) → 2(К) → 7(Ч) → 5(К) → NIL: **2 Черных Узла** (11, 7)
        *   Путь 11(Ч) → 14(Ч) → NIL: **2 Черных Узла** (11, 14)
        *   Путь 11(Ч) → 14(Ч) → 15(К) → NIL: **2 Черных Узла** (11, 14)
    *   Все пути имеют одинаковую черную высоту.

![Диаграмма красно-черного дерева, показывающая внутренние узлы и листья NIL.](image.png)

---

### 3. Как Это Обеспечивает Баланс

Свойство 5 является ключом к гарантии баланса. Оно гарантирует, что ни один путь от корня до листа не будет более чем **вдвое длиннее** любого другого.

*   **Самый короткий возможный путь** в основном черный (например, 11(Ч) → 14(Ч) → NIL).
*   **Самый длинный возможный путь** чередует красные и черные узлы (например, 11(Ч) → 2(К) → 7(Ч) → 5(К) → NIL).

Из-за Свойства 4 (не может быть двух красных подряд) вы не можете добавить больше красных узлов на путь, не добавляя также черные узлы. Это ограничение удерживает самый длинный путь в пределах удвоенной длины самого короткого.

**Результат:** Высота дерева всегда **O(log n)**, что гарантирует эффективность операций поиска, вставки и удаления.

### Итог Ограничений

| Свойство | Описание                                 | Визуальная Гарантия                                                             |
| :------- | :--------------------------------------- | :------------------------------------------------------------------------------ |
| **1**    | Цвет узла Красный или Черный.            | `(К)` или `(Ч)` на каждом узле.                                                 |
| **2**    | Корень черный.                           | Верхний узел `(Ч)`.                                                             |
| **3**    | Все листья (NIL) черные.                 | Все указатели `NIL` черные (■).                                                 |
| **4**    | Красные узлы имеют черных потомков.      | Никакие два узла `(К)` не соединены напрямую по вертикали.                      |
| **5**    | Одинаковое количество черных до листьев. | Для любого узла подсчет узлов `(Ч)` вниз до любого `NIL` дает одинаковое число. |

---

### Страж (`T.nil`): Техническое Удобство

**Проблема:** В коде обработка обычных узлов, которые имеют указатели `parent`, `left` и `right`, отличается от обработки листьев NIL (у которых их нет), что усложняет алгоритмы.

**Решение:** Использовать единственный, общий **страж-узел**, называемый `T.nil`, для представления всех NIL.

**До:**
```
    26
    / \
  17  41
 / \  / \
NIL NIL NIL NIL  // Каждый NIL отделен, без родителя.
```

**После:**
```
       26
      /  \
    17    41
   / \    / \
  ▼   ▼  ▼   ▼  // Все указатели на NIL теперь указывают на единый объект T.nil.
      \
       T.nil (ЧЕРНЫЙ)
```

![Диаграмма, показывающая, как все указатели NIL заменены указателями на единый страж-узел.](image-1.png)

**`T.nil` — это «универсальный солдат»:**
*   Его цвет всегда **ЧЕРНЫЙ** (удовлетворяет Свойству 3).
*   Он имеет все те же атрибуты, что и обычный узел (например, `parent`), упрощая логику кода.
*   Он экономит память (один объект вместо многих NIL).

---

### Понимание Черной Высоты

**Определение:** **Черная высота** узла `x` — это количество **черных узлов** на любом простом пути от `x` вниз до листа (NIL), **не включая** сам `x`.

**Пример:**
```
    26(Ч)  // Не считается!
    /    \
  17(К)   41(Ч)  // Считаем черные узлы отсюда вниз.
```

От узла 26 до любого листа:
*   Путь 26 → 17(К) → 14(Ч) → NIL: **1 Черный Узел** (14)
*   Путь 26 → 41(Ч) → 30(К) → NIL: **1 Черный Узел** (41)

**Ключевое Наблюдение:** Из-за Свойства 5 эта черная высота **идентична** для всех путей от данного узла, что и гарантирует, что дерево остается сбалансированным.

![Диаграмма сложного красно-черного дерева с указанной черной высотой для каждого узла.](image-2.png)

---

### Заключение

1.  **Цвета — это Инструмент:** Конкретная раскраска — это средство для достижения цели (баланса), а не сама цель.
2.  **Страж (`T.nil`)** — это техническая уловка для упрощения кода.
3.  **Черная Высота** — это ключевая метрика, которая, будучи保持一致ной на всех путях, гарантирует логарифмическую высоту дерева.

---
---
---

## 📌 Лемма 13.1 Утверждение

> Красно-черное дерево с `n` внутренними узлами имеет высоту не более `2 lg(n + 1)`.

Математически, если мы обозначим высоту дерева как `h`:
$$h \leq 2 \log_2(n + 1)$$
Это гарантирует, что дерево остается приблизительно сбалансированным, так как его высота растет только логарифмически с количеством узлов.
> Просто границы

---

## 🧠 Часть 1: Основное Утверждение & Настройка Индукции

Стратегия доказательства — сначала доказать более сильное утверждение о структуре дерева.

**Утверждение:** Поддерево с корнем в любом узле `x` содержит как минимум `2^{bh(x)} - 1` (**Это МИНИМАЛЬНОЕ количество узлов в поддереве с корнем в x**) внутренних узлов.

Где `bh(x)` — это **черная высота** узла `x` — количество черных узлов на любом пути от `x` до листа (не включая сам `x`).

> Простыми словами: "Если у вас много черных узлов на путях, то должно быть много общих узлов"

### **ДЕРЕВО НА РИСУНКЕ 13.1:**
```text
        26(Ч) bh=2
        /         \
      17(К)       41(Ч) bh=1
     /    \       /    \
   14(Ч)  21(Ч)  30(К)  47(К)
   bh=1   bh=1   bh=1   bh=1
  /  \    /  \   /  \   /  \
 ■    ■  ■    ■ ■    ■ ■    ■
bh=0     bh=0    bh=0   bh=0
```

### Доказательство по Индукции по Высоте `x`

#### **Базовый Случай: Высота `x` равна 0**
Если высота `x` равна 0, то `x` должен быть листом (`T.nil`).
*   Черная высота листа (`T.nil`) равна 0: `bh(x) = 0`.
*   Количество внутренних узлов в поддереве с корнем в листе равно 0.

Проверим утверждение:
$$ 2^{bh(x)} - 1 = 2^0 - 1 = 1 - 1 = 0 $$
Утверждение выполняется, так как `0 >= 0`.

#### **Индуктивный Шаг: Высота `x` > 0**
Мы предполагаем, что утверждение верно для всех узлов с высотой меньше, чем высота `x`.

Узел `x` является внутренним узлом с положительной высотой, поэтому у него есть два потомка. Каждый потомок может быть внутренним узлом или `T.nil`.

**Ключевое Наблюдение:** Черная высота потомка зависит от его цвета относительно `x`.
*   Если потомок **ЧЕРНЫЙ**, его черная высота равна `bh(x) - 1`.
    *   Почему? Путь проходит через этого черного потомка, который *учитывается* в его собственной черной высоте, поэтому у нас остается `bh(x) - 1` черных узлов для достижения исходного счета.
*   Если потомок **КРАСНЫЙ**, его черная высота равна `bh(x)`.
    *   Почему? Путь проходит через этого красного потомка, который *не учитывается* в его собственной черной высоте, поэтому нам все еще нужно все `bh(x)` черных узлов.

Поскольку высота каждого потомка меньше высоты `x`, мы можем применить **индуктивное предположение** к ним.

*   **Минимум узлов в поддереве левого потомка:** `2^{bh(child_{left})} - 1`
*   **Минимум узлов в поддереве правого потомка:** `2^{bh(child_{right})} - 1`

Черная высота потомка *как минимум* `bh(x) - 1` (это наихудший случай для нашего подсчета, который происходит, если потомок черный). Следовательно, поддерево каждого потомка имеет как минимум:
$$ 2^{bh(x) - 1} - 1 \text{ внутренних узлов} $$

Теперь общее количество внутренних узлов в поддереве с корнем в `x` равно:
\[ \text{(Узлы в левом поддереве)} + \text{(Узлы в правом поддереве)} + \text{(Сам узел x)} \]
\[ \geq \left[2^{bh(x)-1} - 1\right] + \left[2^{bh(x)-1} - 1\right] + 1 \]
\[ = 2 \cdot \left(2^{bh(x)-1} - 1\right) + 1 \]
\[ = 2^{bh(x)} - 2 + 1 \]
\[ = 2^{bh(x)} - 1 \]

Это завершает индуктивный шаг и доказывает основное утверждение. ✅

---

## 🔗 Часть 2: Связь с Высотой Дерева

Теперь мы свяжем это структурное утверждение с общей высотой `h` дерева.

Пусть `h` — высота всего красно-черного дерева.

Из **Свойства 4** (красный узел должен иметь черных потомков) мы знаем, что на любом пути от корня до листа **по крайней мере половина** узлов (исключая сам корень) должна быть черной.

Пусть `bh(root)` — черная высота корня.
*   Самый длинный путь от корня до листа имеет длину `h`.
*   По крайней мере половина этих `h` узлов (не считая корень) черные.
*   Следовательно, количество черных узлов на этом пути, которое равно `bh(root)`, должно быть не менее `h/2`:

$$ bh(root) \geq \lceil h/2 \rceil $$
Для простоты в доказательстве мы используем:
$$ bh(root) \geq h/2 $$

Теперь мы применяем наше ранее доказанное утверждение к **корню** всего дерева. Все дерево имеет `n` внутренних узлов и корень в корне, поэтому:
$$ n \geq 2^{bh(root)} - 1 $$
Подставляя `bh(root) >= h/2`:
$$ n \geq 2^{h/2} - 1 $$

---

## 📐 Часть 3: Финальные Алгебраические Преобразования

Теперь мы выразим `h` через `n`.

Начнем с:
$$ n \geq 2^{h/2} - 1 $$

Добавим 1 к обеим сторонам:
$$ n + 1 \geq 2^{h/2} $$

Возьмем логарифм по основанию 2 от обеих сторон:
$$ \log_2(n + 1) \geq \log_2(2^{h/2}) $$
$$ \log_2(n + 1) \geq h/2 $$

Умножим обе стороны на 2, чтобы выразить `h`:
$$ 2 \log_2(n + 1) \geq h $$

Или, что то же самое:
$$ h \leq 2 \log_2(n + 1) $$

**Это именно то, что мы и хотели доказать.** 🎉

---
## 💡 Следствия Леммы

Как указано в тексте, эта лемма является фундаментальной. Поскольку высота `h` красно-черного дерева равна `O(log n)`, все базовые операции над динамическими множествами, выполняемые за время, пропорциональное высоте в БДП, теперь выполняются за время `O(log n)` на красно-черном дереве.

* `SEARCH`, `MINIMUM`, `MAXIMUM`, `SUCCESSOR`, `PREDECESSOR` все имеют время `O(log n)`.

В тексте также отмечается важный момент: хотя стандартные операции БДП `INSERT` и `DELETE` выполняются за время `O(log n)` *для* красно-черного дерева, они не сохраняют свойства красно-черного дерева. В оставшейся части главы подробно описывается, как модифицировать эти операции, чтобы сохранить свойства, при этом достигнув временной сложности `O(log n)`.

---
---
## 🔄 13.2 Повороты

**Проблема:** Операции TREE-INSERT и TREE-DELETE в красно-черном дереве могут нарушить его балансировку. Необходим механизм для восстановления структуры без потери свойства бинарного поиска.

**Решение:** Повороты — это локальные операции, которые изменяют структуру указателей, но сохраняют свойство бинарного поиска.

### 🎯 Что такое поворот?

Поворот — это операция «скручивания» родительско-дочерних связей, изменяющая их иерархию, но сохраняющая порядок ключей.

> **Аналогия:** Представьте дерево в виде мобиля. Если потянуть за одну ветку и «повернуть» её, общая структура изменится, но все элементы останутся в своём относительном порядке.

### Два типа поворотов

![alt text](image-3.png)

**Ключевые наблюдения:**
- **Поворот влево** делает правый дочерний элемент родительским
- **Поворот вправо** делает левый дочерний элемент родительским
- Оба поворота **взаимно обратны**
- Время выполнения: **O(1)** — изменяется только постоянное количество указателей

### 💻 Псевдокод LEFT-ROTATE

```псевдокод
LEFT-ROTATE(T, x)
1 y = x.right // установить y
2 x.right = y.left // преобразовать левое поддерево y в правое поддерево x
3 if y.left ≠ T.nil
4 y.left.p = x // обновить родительский элемент левого поддерева y
5 y.p = x.p // переместить родительский элемент x в y
6 if x.p == T.nil
7 T.root = y // если x был корнем, то теперь y — корень
8 elseif x == x.p.left
9 x.p.left = y // если x был левым потомком
10 else x.p.right = y // если x был правым потомком
11 y.left = x // сделать x левым потомком y
12 x.p = y // обновить родителя x
```

### Визуализация вращения (рис. 13.3)

![alt text](image-4.png)

**Что изменилось:**
- `y` (18) стал новым корнем поддерева
- `x` (11) стал левым потомком `y`

### 🔄 Симметричный псевдокод RIGHT-ROTATE

```псевдокод
RIGHT-ROTATE(T, y)
1 x = y.left // установить x
2 y.left = x.right // преобразовать правое поддерево x в левое поддерево y
3 if x.right ≠ T.nil
4 x.right.p = y // обновить родительский элемент правого поддерева x
5 x.p = y.p // переместить родительский элемент y в x
6 if y.p == T.nil
7 T.root = x // если y был корнем, то x — корень
8 elseif y == y.p.left
9 y.p.left = x // если y был левым потомком
10 else y.p.right = x // если y был правым потомком
11 x.right = y // переместить y в правый потомок x
12 y.p = x // обновить родительский элемент y
```

### Ключевые свойства поворотов

1. **Сохранение свойства BST:** Порядок ключей остаётся неизменным
2. **Локальность:** изменяется лишь небольшой фрагмент дерева.
3. **Обратимость:** операции LEFT-ROTATE и RIGHT-ROTATE взаимно обратны.
4. **Эффективность:** время O(1), константная память.

### 💡 Зачем это нужно в красно-черных деревьях?

Повороты используются в сочетании с перекраской для:
- **Восстановления свойства 4** (отсутствия двух последовательных красных узлов)
- **Сохранения свойства 5** (одинаковой высоты чёрных узлов)
- **Балансировки дерева** после вставки/удаления

---

### Заключение

**Повороты являются фундаментальным строительным блоком** для всех операций балансировки в красно-черных деревьях. Они позволяют «реструктурировать» дерево, сохраняя его поисковые свойства, но улучшая его балансировку.

> **Как и в строительстве:** Вы можете переместить балку (повернуть), чтобы перераспределить нагрузку, но общая конструкция дома (свойство BST) останется неизменной.


---
---
## 🔴 13.3 Вставка

**Основная идея:** Вставка в красно-черное дерево состоит из двух этапов:
1. **Обычная BST-вставка** + покраска нового узла в **красный**
2. **Исправление нарушений** с помощью перекрашиваний и поворотов

### 🎯 Почему новый узел всегда КРАСНЫЙ?

> **Упражнение 13.3-1:** Почему не покрасить новый узел в чёрный?

**Ответ:** Если новый узел `z` сделать чёрным, мы **гарантированно нарушим свойство 5** (одинаковая чёрная высота)! Все пути через этот узел будут иметь +1 чёрный узел. Исправлять это сложнее, чем возможное нарушение свойства 4 (два красных подряд).

### 💻 Псевдокод RB-INSERT

```псевдокод
RB-INSERT(T, z)
1   x = T.root                    // начинаем с корня
2   y = T.nil                     // y будет родителем z
3   while x ≠ T.nil               // спускаемся до листа
4       y = x
5       if z.key < x.key
6           x = x.left
7       else x = x.right
8   z.p = y                       // нашли родителя для z
9   if y == T.nil                 // дерево было пустым
10      T.root = z
11  elseif z.key < y.key
12      y.left = z
13  else y.right = z
14  z.left = T.nil               // инициализируем детей
15  z.right = T.nil
16  z.color = RED                // КЛЮЧЕВОЙ МОМЕНТ: красим в красный
17  RB-INSERT-FIXUP(T, z)        // исправляем возможные нарушения
```

### 🔧 RB-INSERT-FIXUP: Исправление нарушений

**Какие свойства могут нарушиться?**
- ✅ **Свойство 1** (цвета): остаётся
- ✅ **Свойство 3** (листья чёрные): остаётся
- ✅ **Свойство 5** (чёрная высота): остаётся
- ❗ **Свойство 2** (корень чёрный): нарушится если `z` стал корнем
- ❗ **Свойство 4** (нет двух красных подряд): нарушится если родитель `z` красный

### 🎨 Три случая исправления

#### **Случай 1: Дядя КРАСНЫЙ**
```
    черный(B)
    /       \
 красный(R)  красный(R) ← дядя y
   /  \       /   \
  ... z(R)   ...   ...
```

**Решение:** Перекрашиваем родителя и дядю в чёрный, дедушку в красный, поднимаем `z` на уровень дедушки.

```псевдокод
if y.color == RED:           // случай 1
    z.p.color = BLACK
    y.color = BLACK
    z.p.p.color = RED
    z = z.p.p               // поднимаем z на 2 уровня
```

#### **Случай 2: Дядя ЧЁРНЫЙ, z - правый ребёнок**
```
    черный(B)
    /       \
 красный(R)  черный(B) ← дядя y
   /  \
  ...  z(R) ← правый ребёнок
```

**Решение:** Левый поворот вокруг родителя, превращаем в случай 3.

```псевдокод
if z == z.p.right:          // случай 2
    z = z.p
    LEFT-ROTATE(T, z)
// переходим к случаю 3...
```

#### **Случай 3: Дядя ЧЁРНЫЙ, z - левый ребёнок**
```
    черный(B)
    /       \
 красный(R)  черный(B) ← дядя y
   /  \
 z(R) ... ← левый ребёнок
```

**Решение:** Перекрашиваем + правый поворот вокруг дедушки.

```псевдокод
z.p.color = BLACK          // случай 3
z.p.p.color = RED
RIGHT-ROTATE(T, z.p.p)
```

### 📊 Визуальный пример (Рисунок 13.4)

![alt text](image-5.png)

          ┌─────────────────────────────────────────────────────────────────┐
          │                 РИСУНОК 13.4 - RB-INSERT-FIXUP                  │
          └─────────────────────────────────────────────────────────────────┘

(a) █ Узел z после вставки. Поскольку и z, и его родительский узел z.p красные,
происходит нарушение СВОЙСТВА 4. Поскольку дядя узла z y — КРАСНЫЙ,
применяется СЛУЧАЙ 1 в коде. Прародитель узла z z.p.p должен быть ЧЁРНЫМ,
и его чёрность передается на один уровень вниз к родителю и дяде узла z.
Как только указатель z перемещается на два уровня вверх в дереве,
получается дерево, показанное на (b).

(b) █ И снова z и его родительский узел красные, но на этот раз дядя узла z y — ЧЁРНЫЙ. Поскольку z — ПРАВЫЙ потомок узла z.p, применяется СЛУЧАЙ 2.

(c) █ Выполнение поворота ВЛЕВО приводит к дереву, показанному на (c).
Теперь z — ЛЕВЫЙ потомок своего родителя.

(d) █ Применяется СЛУЧАЙ 3. Перекраска и поворот вправо дают дерево (d), которое является ПРАВИЛЬНЫМ КРАСНО-ЧЕРНЫМ ДЕРЕВОМ.


### 🔄 Полный псевдокод RB-INSERT-FIXUP

```псевдокод
RB-INSERT-FIXUP(T, z)
1   while z.p.color == RED
2       if z.p == z.p.p.left           // родитель - левый ребёнок
3           y = z.p.p.right            // дядя
4           if y.color == RED          // СЛУЧАЙ 1
5               z.p.color = BLACK
6               y.color = BLACK
7               z.p.p.color = RED
8               z = z.p.p
9           else
10              if z == z.p.right      // СЛУЧАЙ 2
11                  z = z.p
12                  LEFT-ROTATE(T, z)
13              z.p.color = BLACK      // СЛУЧАЙ 3
14              z.p.p.color = RED
15              RIGHT-ROTATE(T, z.p.p)
16       else                          // симметрично для правого ребёнка
17           // ... те же случаи с left/right поменяны местами
18   T.root.color = BLACK              // гарантируем чёрный корень
```


---

![alt text](image-6.png)

### **Случай 1: Дядя КРАСНЫЙ**

**Проблема:**
Узел `z` и его родитель `z.p` - оба КРАСНЫЕ → нарушение **Свойства 4** (два красных подряд)

**🎯 Условие Случая 1:**
- Дядя `y` (брат родителя) тоже **КРАСНЫЙ**

**🔄 Решение: "Спуск черноты"**

**Шаги:**
1. `z.p.color = BLACK`    ← родитель стал ЧЁРНЫМ
2. `y.color = BLACK`      ← дядя стал ЧЁРНЫМ
3. `z.p.p.color = RED`    ← дедушка стал КРАСНЫМ
4. `z = z.p.p`           ← перемещаем указатель на дедушку

**✅ Что исправлено:**
- **Свойство 4**: между `z` и родителем больше нет нарушения
- **Свойство 5**: чёрная высота сохраняется - мы просто "перераспределили" черноту

**Что дальше:**
- `z` теперь указывает на дедушку (красный)
- Если дедушка стал корнем → нарушение Свойства 2 (исправим позже)
- Если у дедушки красный родитель → новое нарушение Свойства 4 (повторяем цикл!)

**Особенности Случая 1:**
- НЕТ поворотов - только перекрашивание
- `z` поднимается на 2 уровня вверх
- Может создать новое нарушение выше по дереву
- Цикл продолжается с новым `z`
---

![alt text](image-7.png)

🔄 **Случаи 2 и 3: Дядя ЧЁРНЫЙ**

**Проблема:**
`z` и родитель `z.p` - оба КРАСНЫЕ → нарушение **Свойства 4**

**Условие:**
Дядя `y` - **ЧЁРНЫЙ**

---

### Случай 2: `z` - ПРАВЫЙ ребёнок

**🔄 Преобразование:**
- Левый поворот вокруг родителя
- Случай 2 → Случай 3

**Код:**
```псевдокод
z = z.p
LEFT-ROTATE(T, z)
// переходим к Случаю 3...
```

---

### Случай 3: `z` - ЛЕВЫЙ ребёнок

**Финальное решение:**
1. `z.p.color = BLACK`       ← родитель → ЧЁРНЫЙ
2. `z.p.p.color = RED`       ← дедушка → КРАСНЫЙ
3. `RIGHT-ROTATE(T, z.p.p)`  ← правый поворот вокруг дедушки

**✅ Результат:**
- **Свойство 4** восстановлено - нет двух красных подряд
- **Свойство 5** сохранено - чёрная высота не изменилась
- Цикл **ЗАВЕРШАЕТСЯ** - родитель теперь чёрный

---

### Ключевые моменты:

**Случай 2 → Случай 3:**
- Просто подготавливаем структуру
- Левый поворот выравнивает `z` как левого ребёнка

**Случай 3 - ФИНАЛЬНЫЙ:**
- Перекрашивание + правый поворот
- Полностью устраняет нарушение
- Цикл завершается на следующей итерации

**Результат:** Дерево снова становится валидным красно-чёрным деревом!

---
---

# 🔄 **13.4 Удаление - Удаление из красно-черного дерева**

**🎯 Основная идея:** Удаление сложнее вставки, но тоже работает за **O(log n)**

---

### 🔧 **RB-TRANSPLANT - Модифицированная замена**

```псевдокод
RB-TRANSPLANT(T, u, v)
1   if u.p == T.nil          // u - корень
2       T.root = v
3   elseif u == u.p.left     // u - левый ребенок
4       u.p.left = v
5   else                     // u - правый ребенок
6       u.p.right = v
7   v.p = u.p               // ВСЕГДА обновляем родителя v
```

**Отличия от обычного TRANSPLANT:**
- Работает с `T.nil` вместо `NIL`
- Всегда обновляет `v.p` (даже если `v = T.nil`)

---

### 🗑️ **RB-DELETE - Основная процедура удаления**

```псевдокод
RB-DELETE(T, z)
1   y = z                    // y - удаляемый узел
2   y-original-color = y.color
3   if z.left == T.nil       // нет левого ребенка
4       x = z.right
5       RB-TRANSPLANT(T, z, z.right)
6   elseif z.right == T.nil  // нет правого ребенка
7       x = z.left
8       RB-TRANSPLANT(T, z, z.left)
9   else                     // есть оба ребенка
10      y = TREE-MINIMUM(z.right)  // преемник
11      y-original-color = y.color
12      x = y.right
13      if y != z.right      // преемник не прямой правый ребенок
14          RB-TRANSPLANT(T, y, y.right)
15          y.right = z.right
16          y.right.p = y
17      RB-TRANSPLANT(T, z, y)
18      y.left = z.left
19      y.left.p = y
20      y.color = z.color
21  if y-original-color == BLACK
22      RB-DELETE-FIXUP(T, x)  // исправляем нарушения
```

---

### 🎨 **Что такое "дополнительная чернота"?**

**Проблема:** При удалении ЧЁРНОГО узла `y` нарушается **Свойство 5** (чёрная высота)

**Решение концепции:**
- Узел `x` получает **"дополнительную черноту"**
- `x` становится либо:
  - **"Дважды чёрным"** (черный + дополнительная чернота)
  - **"Красно-чёрным"** (красный + дополнительная чернота)

**Цель RB-DELETE-FIXUP:** Избавиться от дополнительной черноты!

---

### 🔧 **RB-DELETE-FIXUP - 4 случая исправления**

**Случай 1: Брат `w` - КРАСНЫЙ**
```псевдокод
// Брат w красный → делаем его черным
w.color = BLACK
x.p.color = RED
LEFT-ROTATE(T, x.p)
w = x.p.right
// Переходим к Случаю 2, 3 или 4
```

**Случай 2: Брат `w` - ЧЁРНЫЙ, оба ребенка `w` - ЧЁРНЫЕ**
```псевдокод
// Убираем черноту с w, переносим дополнительную черноту вверх
w.color = RED
x = x.p  // Поднимаем x на уровень выше
```

**Случай 3: Брат `w` - ЧЁРНЫЙ, левый ребенок `w` - КРАСНЫЙ, правый - ЧЁРНЫЙ**
```псевдокод
// Подготовка к Случаю 4
w.left.color = BLACK
w.color = RED
RIGHT-ROTATE(T, w)
w = x.p.right
// Переходим к Случаю 4
```

**Случай 4: Брат `w` - ЧЁРНЫЙ, правый ребенок `w` - КРАСНЫЙ**
```псевдокод
// ФИНАЛЬНОЕ решение - убираем дополнительную черноту!
w.color = x.p.color
x.p.color = BLACK
w.right.color = BLACK
LEFT-ROTATE(T, x.p)
x = T.root  // Завершаем цикл!
```

![alt text](image-8.png)
---

### ⏱ **Анализ сложности**

- **RB-DELETE:** O(log n) - поиск + трансплантация
- **RB-DELETE-FIXUP:** O(log n) - двигаемся вверх по дереву
- **Повороты:** не более 3 поворотов на удаление

**Итого:** O(log n) время, O(1) дополнительной памяти

---

### 🎯 **Ключевые моменты:**

1. **Только удаление ЧЁРНОГО узла** требует исправлений
2. **Концепция "дополнительной черноты"** - элегантное решение для Свойства 5
3. **4 случая** покрывают все возможные конфигурации
4. **Случай 1 → Случай 2/3/4** - подготовительный
5. **Случай 4** - единственный, который полностью устраняет дополнительную черноту

**Результат:** Дерево остается валидным красно-чёрным деревом после удаления! 🎉

---
---
# 🔴 **Персистентные Красно-Черные Деревья** (Задача 13-1)

## **Проблема персистентных структур**
Нужно поддерживать **все версии** множества при изменениях, но копировать всё дерево каждый раз - слишком дорого!

## **Решение для обычного BST**
**Идея:** Копируем только измененные узлы на пути от корня!

**Пример из Figure 13.8:**
![alt text](image-9.png)

### 📝 **Ответы на подпункты:**

**a) Какие узлы меняются?**
- Все узлы на пути от корня до вставляемого/удаляемого узла
- Их непосредственные дети, на которых влияет изменение

**b) PERSISTENT-TREE-INSERT:**
```псевдокод
PERSISTENT-TREE-INSERT(T, z)
1   if T.root == NIL
2       new_root = COPY-NODE(z)
3       return new tree with root new_root
4   new_root = COPY-NODE(T.root)
5   x = new_root
6   y = NIL
7   while x != NIL
8       y = x
9       if z.key < x.key
10          x = COPY-NODE(x.left)  // копируем при спуске!
11          y.left = x
12      else
13          x = COPY-NODE(x.right)
14          y.right = x
15   // Вставляем z как ребенка y
16   if z.key < y.key
17       y.left = z
18   else
19       y.right = z
20   return new tree with root new_root
```

**c) Время и память: O(h)**
- Копируем только h узлов на пути
- Память: O(h) новых узлов
- Время: O(h) операций

**d) С родительскими указателями - O(n) в худшем случае**
При изменении родителя узла, нужно копировать всех его потомков!

**e) Решение с красно-чёрными деревьями: O(log n)**
Используем персистентные КЧД - гарантированная высота O(log n) ⇒ O(log n) времени и памяти на операцию!

---

# 🔗 **Операция Слияния** (Задача 13-2)

## **Задача объединения**
Даны два КЧД T₁ и T₂ и ключ x, где все ключи T₁ < x < все ключи T₂. Объединить в одно КЧД.

## 🛠 **Решение:**

**a) Поддержка black-height:**
- Можно вычислять на лету при спуске по дереву
- Не нужно хранить отдельно!

**b) Поиск черного узла в T₁ с black-height = T₂.bh:**
- Спускаемся по правым детям, поддерживая текущую black-height
- Время: O(log n)

**c) Быстрая замена: O(1)**
```псевдокод
// T_y - поддерево с корнем y
new_node = Node(x)
new_node.left = y
new_node.right = T₂.root
y.parent = new_node
T₂.root.parent = new_node
```

**d) Цвет для x:**
- Делаем x **КРАСНЫМ** (сохраняем Свойства 1,3,5)
- Исправляем Свойства 2,4 за O(log n) с помощью RB-INSERT-FIXUP

**e) Симметричный случай:** Когда T₁.bh ≥ T₂.bh

**f) Общее время: O(log n)** - ограничено высотой деревьев

---

# **AVL Деревья** (Задача 13-3)

## 🎯 **Балансировка по высоте**
Для каждого узла: $$|height(left) - height(right)| ≤ 1$$

**a) Доказательство высоты O(log n):**
- Минимальное число узлов в AVL дереве высоты h: N(h) ≥ Fₕ (числа Фибоначчи)
- Fₕ растет экспоненциально ⇒ h = O(log n)

**b) Процедура BALANCE(x):**
Используем **4 типа поворотов** как в КЧД:
- Left-Left case: один правый поворот
- Right-Right case: один левый поворот
- Left-Right case: левый + правый поворот
- Right-Left case: правый + левый поворот

**c) AVL-INSERT:**
1. Обычная BST-вставка
2. Поднимаемся вверх, пересчитывая высоты
3. Если нашли несбалансированный узел - применяем BALANCE

**d) Анализ: O(log n) времени, O(log n) поворотов**
- Высота O(log n) ⇒ O(log n) шагов вверх
- Максимум O(1) поворотов на уровень

---

## 🏆 **Сравнение структур:**

| Структура           | Гарантия                 | Сложность операций   |
| ------------------- | ------------------------ | -------------------- |
| **Red-Black Trees** | height ≤ 2log(n+1)       | O(log n)             |
| **AVL Trees**       | строгий баланс по высоте | O(log n)             |
| **Persistent RBT**  | все версии + O(log n)    | O(log n) на операцию |
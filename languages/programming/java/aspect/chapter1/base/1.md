# **AspectJ Overview: Key concepts and examples**

## **1. Basic concepts of AspectJ**

### **1.1 Join Point**
A Join Point is a point in the execution of a program where an aspect can be applied. In the example with the `Account` class:
```java
void credit(float amount) {
    _balance += amount;
}
```
Join points include:
- Execution of the `credit()` method
- Access to the `_balance` field

### **1.2 Pointcut (Slice)**
Pointcut defines a set of join points and collects the context. pointcut example for the `credit()` method:
```java
execution(void Account.credit(float))
```

### **1.3 Advice**
Advice is the code executed at the connection point. May be:
- `before` — before execution
- `after` — after the execution
- `around` — around execution (may modify behavior)

Example of advice for logging:
```java
before() : execution(void Account.credit(float)) {
    System.out.println("About to perform credit operation");
}
```

### **1.4 Introduction**
Modifies the structure of classes at the compilation stage. Example of adding an interface:
```java
declare parents: Account implements Banking Identity;
```

### **1.5 Aspect**
The main unit of modularity in AspectJ, combining crosscutting functionality:
```java
public aspect ExampleAspect {
    before() : execution(void Account.credit(float)) {
        System.out.println("About to perform credit operation");
    }
    declare parents: Account implements BankingEntity;
}
```

## **2. A practical example: Hello World**

### **2.1 Basic Classes**
```java
public class MessageCommunicator {
    public static void deliver(String message) {
        System.out.println(message);
    }
    public static void deliver(String person, String message) {
        System.out.print(person + ", " + message);
    }
}

public class Test {
    public static void main(String[] args) {
        MessageCommunicator.deliver("Wanna learn AspectJ?");
        MessageCommunicator.deliver("Harry", "having fun?");
    }
}
```

### **2.2 Aspect for adding greetings**
```java
public aspect MannersAspect {
    pointcut deliverMessage() : call(* MessageCommunicator.deliver(..));
    
    before() : deliverMessage() {
        System.out.print("Hello! ");
    }
}
```
Execution result:
```
Hello! Wanna learn AspectJ?
Hello! Harry, having fun?
```

### **2.3 Aspect for modifying arguments**
```java
public aspect HindiSalutationAspect {
    pointcut sayToPerson(String person) : 
        call(* MessageCommunicator.deliver(String, String)) && args(person, String);
    
    void around(String person) : sayToPerson(person) {
proceed(person + "-ji"); // Modifying the argument
    }
}
```
The final conclusion:
```
Hello! Wanna learn AspectJ?
Hello! Harry-ji, having fun?
```

## **3. How AspectJ works under the hood**

### **3.1 Conversion to Bytecode**
- Aspects are converted to regular Java classes
- Advice becomes methods that are called at connection points
- Pointcut determines where to insert advice method calls
- Introduction modifies the class structure

Example of the transformation of the `MannersAspect` aspect:
```java
public class MannersAspect {
public static MannersAspect aspectInstance;
    
    public final void before0$ajc() {
        System.out.print("Hello! ");
    }
    
    static {
        MannersAspect.aspectInstance = new MannersAspect();
    }
}
```

### **3.2 Modified MessageCommunicator class**
```java
public class MessageCommunicator {
    public static void deliver(String message) {
        MannersAspect.aspectInstance.before0$ajc();
        System.out.println(message);
    }
    
    public static void deliver(String person, String message) {
        MannersAspect.aspectInstance.before0$ajc();
        System.out.print(person + ", " + message);
    }
}
```

## **4. AspectJ Application**
1. **Logging** - centralized logging without modification of the main code
2. **Transactions** - Automatic transaction management
3. **Security** - access rights verification
4. **Caching** - transparent addition of caching
5. **Metrics** - collecting statistics on the execution of methods

AspectJ provides a powerful mechanism for implementing end-to-end functionality, keeping the core code clean and focused on business logic.
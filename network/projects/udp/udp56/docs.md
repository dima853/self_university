# Additional materials
- https://beej.us/guide/bgnet/pdf/bgnet_usl_c_1.pdf

# Architecture UPD/53
### **UDP/53 architecture (DNS over UDP) - Clean structure without code**  

#### **1. The general algorithm of work**  
1. **The client** generates a DNS query (binary packet according to RFC 1035).
2. **Sending** via a UDP socket to port 53 of the DNS server.  
3. **Server** processes the request and returns a response.
4. **The client** parses the response and extracts the necessary data (IP, CNAME, etc.).  

---

#### **2. System components**  

**1) Network Layer (UDP):**  
- Creating a socket (`socket()`).
- Binding to a port (optional for the client).  
- Setting timeouts (`setsockopt()`).  

**2) DNS query generation:**  
- **Headline:**
- `ID` (unique identifier).  
  - `Flags` (RD=1 for recursion, Opcode, other flags).  
  - `QDCOUNT` = `1` (one question).  
- **Question Section:**
- `QNAME` (domain in a special format, e.g. `3www6google3com0`).  
  - `QTYPE` (A, AAAA, MX, etc.).
- `QCLASS` (usually `IN`).  

**3) Sending/receiving data:**  
- `sendto()` — sending a request.  
- `recvfrom()` — receiving a response (max 512 bytes for UDP).  

**4) Response parsing:**  
- Checking the `ID` (must match the request).  
- RCODE analysis (0 = OK, 3 = NXDOMAIN, etc.).
- Data extraction from sections:  
  - `Answer` (IP address).  
  - `Authority` (name servers).  
  - `Additional` (additional data).  

**5) Error handling:**  
- Timeouts (`recvfrom()` with `SO_RCVTIMEO`).  
- Check the `TC=1` flag (TCP is needed for large responses).  
- Repeat requests if necessary.  

---

#### **3. Interaction scheme**  
```
Client:  
1. socket() → 2. Generates a DNS query → 3. sendto()
4. recvfrom() → 5. Parses the response → 6. close()  

The server:  
1. Accepts the request → 2. Searches the DATABASE/cache → 3. Sends the response  
```

---

#### **4. Features of UDP/53**  
- **Max. packet size:** 512 bytes (if larger, `TC=1` and switch to TCP).  
- **Recursion:** If the server does not support (RD=0), the client makes the requests itself.  
- **Caching:** Local cache to speed up repeated requests.  

---

#### **5. What is not included in the architecture (but important)**  
- Support for DNSSEC (data signing).  
- IPv6 (AAAA records).  
- Asynchronous requests (via `select()`/`poll()`).  

---

This framework describes the **basic framework** for implementing a DNS client. For the server, we add:
- A database of records (or a link to higher-level DNS).  
- Processing recursive queries.

# 2. **Formation of a UDP/53 DNS query:**

1. **Preparation of the request data:**

    * **Request ID (Query ID):** A random 16-bit number that is generated by the client (for example, by your program). This ID is used to match the response with the sent request.
    * **Flags:** A set of bit flags that define the query type, recursion, and other parameters. The most important flags:
        *   **QR (Query/Response):** Is set to 0 for the request.
        *   **RD (Recursion Desired):** Is set to 1 if the client wants the DNS server to perform a recursive search for an answer (that is, he himself turned to other DNS servers, if necessary).
    * **Number of questions (Question Count):** Is set to 1 (usually a DNS query contains one question).
    * **Number of answers (Answer Count), Number of authoritative records (Authority Count), Number of additional records (Additional Count):** Set to 0 for the query.
    * **Question:** Contains information about what we want to know:
        * **Domain Name (Query Name):** The domain name that we want to resolve to an IP address (for example, `google.com`). A domain name is represented as a sequence of labels, each of which begins with a byte indicating the length of the label. For example, `google.com `will be encoded as `\x06google\x03com\x00`.
        * **Query Type:** The type of DNS record we want to get. The most common types are:
            * `A` (Address record): Request for an IPv4 address.
            * `AAAA` (Quad-A record): IPv6 address request.
            * `MX` (Mail Exchange record): Request information about the mail server.
            * `CNAME` (Canonical Name record): Request for the canonical domain name.
        * **Query Class:** It is usually set to `IN' (Internet).

2. **Formation of a UDP packet:**

    * All of the above data is collected in a single byte array, which is a DNS query. This byte array becomes the payload of the UDP packet.
    * **UDP header:** A UDP header is added to the payload, which contains information about the source port (the port from which the request was sent), destination port (53 for the DNS server), packet length, and checksum.
    * **IP header:** A UDP packet is encapsulated in an IP packet that contains the source IP address (your IP address) and the destination IP address (DNS server IP address).

3. **Sending a package:**

    * The UDP packet is sent to the DNS server at the specified IP address and port 53.

**Example (simplified) of forming a DNS query for `google.com ` (A-record):**

```
Request ID: 1234 (0x04D2)
Flags: 0x0100 (RD = 1)
Number of questions: 1
Number of responses: 0
Number of authoritative entries: 0
Number of additional entries: 0
Domain name: \x06google\x03com\x00
Request type: A (1)
Request class: IN (1)
```

**Code with `setsockopt' and timeout:**

Now let's see how your setsockopt code affects this process.:

```c
 struct timeval timeout;
 timeout.tv_sec = TIMEOUT_SEC;
 timeout.tv_usec = 0;
 if (setsockopt(sockfd, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout)) < 0) {
  perror("Setsockopt failed");
  close(sockfd);
  return 1;
 }
```

This code sets the *maximum waiting time for a response from the DNS server*. After sending a DNS query, your program will wait for a response from the DNS server. If the response does not arrive within `TIMEOUT_SEC` seconds, then the data acquisition operation (for example, `recvfrom()`) will return an error, and your program will be able to handle this situation (for example, repeat the request or report an error).

**The importance of timeout:**

* The DNS server may be unavailable, overloaded, or the response may be lost on the network. Without a timeout, your program may freeze, waiting for a response that will never arrive.
* Timeout allows your program to remain responsive and handle situations when the DNS server does not respond on time.

**In conclusion:**

The formation of a DNS query includes the preparation of query data (identifier, flags, domain name, query type, etc.), the formation of a UDP packet and sending it to the DNS server. The code with `setsockopt` sets a timeout for waiting for a response from the DNS server, which allows the program to handle situations when the response does not arrive on time.
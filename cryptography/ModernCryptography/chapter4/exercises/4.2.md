Task:
-----
Assume secure MACs exist. Give a construction of a MAC that is secure
 with respect to Definition 4.2 but that is not secure when the adversary
 is additionally given access to a Vrfy oracle (cf. the previous exercise).
-----

def 4.2 
MAC П = (gen. mac, vrfy) 
is existentially unforgeable under an adaptive chosen-message attack, or just secure, if for all PPT adversaries A , there is a negligible fucntion negl such that: 

                Pr[Mac-forge A,П(n) = 1] <= negl(n)  

*A MAC is secure if no efficient adversary can succeed in the above experiment with non-negligible probability

- MAC experiment mac-forge A,П(n)
1. a key K is generated by running Gen(1^n)
2. A <- input 1^n and oracle access to MaCk(.)
The A eventually outputs (m, t). 
Let Q denote the set of all queries that A submitted to its oracle;
3. A succeeds if and only if (1) VrfYk(m,t) = 1 and (2) m != Q.
in that case the output of the experiment is defined to be 1;


Prove:
MAC consist of 3 PPT algorithms (Gen, Mac, Vrfy)
1. Gen takes as input the security parameter 1^n and outputs a key K with |k| >= n.
2. Mac (tag-generator) takes as input a key K and a M belong {0, 1}*, and output a tag T. Since this alorithm may be randomized we write this as T <- MaCk(m).
3. The deterministic Vrfy takes as input a key K, a M and a T . it outputs a bit bm wuth b = 1 meaning valid and b = 0 meaning invalid. We write this as b:= VrfYk(m,t)

and for every n,k by Gen(1^n) and every m belong {0,1}*, it holds that VrfYk(m,MaCk(m)) = 1;

maybe fixed-length MAC for messages of length l(n)

canonical verification
!the canonical way to perform vfry is simply to re-compute the tag and check for equality!

Vrfyk(m,t) first computes ^~t := MaCk(m) -> 1 if and only if ^~t = t (because MAC is deterministic)

- Even for deterministic MACs, though, it is useful to de ne a sepa
rate Vrfy algorithm to explicitly distinguish the semantics of authenticating a
 message to be sent vs. verifying authenticity of a message that was received.


- MAC experiment mac-forge A,П(n)
1. a key K is generated by running Gen(1^n)
2. A <- input 1^n and oracle access to MaCk(.)
The A eventually outputs (m, t). 
Let Q denote the set of all queries that A submitted to its oracle;
3. A succeeds if and only if (1) VrfYk(m,t) = 1 and (2) m != Q.
in that case the output of the experiment is defined to be 1;

### **Proof: Building a MAC that is safe without the Vrfy oracle, but unsafe with it**  

**Given:**  
- There is a secure MAC `Π' = (Gen', Mac', Vrfy')` (satisfying Definition 4.2).  

**Task:**  
Construct a MAC `Π = (Gen, Mac, Vrfy)` that:  
1. **Safe** in the Mac forge experiment (without access to the Vrfy oracle).  
2. **Unsafe** if the opponent gets access to the "Vrfy" oracle.  

---

### **Vulnerable MAC Design**  

1. **Key generation (`Gen`):**
- Run `Gen'(1ⁿ)`, get the key `K'.  
   - We select a random bit `b ← {0,1}`.  
   - We return the key `K = (K', b)`.  

2. **Tag generation (`Mac`):**
- Accepts `m`, the key is `K = (K', b)`.  
   - Calculates `t' ← Mac'_{K'}(m)`.  
   - Returns the tag `t = (b, t')`.  

3. **Verification (`Vrfy'):**
- Accepts `m`, tag `t = (c, t')'.  
   - If `c ≠ b', returns `0`.  
   - Otherwise it returns `Vrfy'_{K'}(m, t')`.  

---

### **Proof of security without a `Vrfy` oracle**  

Consider the Mac forge experiment **without access to the Vrfy oracle**.  

- Opponent `A` can request a `Mac` oracle and receive tags like `(b, Mac'_{K'}(m))`.  
- To forge a tag for a new `m* ∉ Q', `A` must:
1. Guess `b` (probability `1/2`).  
  2. Fake `Mac'_{K'}(m*)` for `Π' (probability of `negl(n)`).  

**The final probability of success:**  
\[
\Pr[\text{Mac-forge}_{A,Π}(n) = 1] \leq \frac{1}{2} \cdot \text{negl}(n) = \text{negl}(n).
\]  
 The `Π` is safe in the sense of Definition 4.2.  

---

### **Attack in the presence of a `Vrfy` oracle**  

Now let `A` have access to the `Vrfy` oracle.  

1. **The attacker recognizes `b`:**
- Selects any `m`, sends `(0, t')` (where `t' is an arbitrary tag) to `Vrfy'.  
     - If the answer is `1', it means `b = 0'.  
     - If `0`, sends `(1, t')` → if the answer is `1`, then `b = 1'.  
   - Now `A` knows `b'.  

2. **Forgery of the tag:**
- Requests `Mac` for any `m`, gets `(b, t')`.  
   - Selects a new `m* ∉ Q`, calculates `t*' ← Mac'_{K'}(m*)(if `Π" is deterministic, you can simply copy the structure).  
   - Returns `(b, t*')`.  

**Attack success:**  
- `Vrfy_K(m*, (b, t*')) = 1`, because `b` is correct and `t*' is a valid tag for `m*`.  
- `m*` has not been requested before, successful forgery.  

**Output:** `Pi` is unsafe in the presence of a 'Vrfy` oracle.  
---

### **Result**  
We have built a MAC `Pi`, which is:
***Safe** in the standard experiment `Mac forge' (without the 'Vrfy` oracle).  
❌ **Unsafe** if the enemy can make requests to `Vrfy'.  

This proves that **access to the verification oracle can weaken the security of the MAC**, even if the scheme was initially secure without it.